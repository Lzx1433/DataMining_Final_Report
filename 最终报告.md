<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });
</script>


# <center>“航班延误预测”期末报告

<font size=4 face="宋体">  

## 项目成员
>* 王俊豪（3120211080）：算法实现，模型训练，数据分析，文档编写   
>* 刘子贤（3120211084）：算法实现，模型训练，可视化，文档编写  
>* 王欣哲（1120182955）：算法实现，构建模型，文档编写    
***  

## 1. 问题提出 
>&emsp;&emsp;随着国内民航的不断发展，航空出行已经成为人们比较普遍的出行方式，但是航班延误却成为旅客们比较头疼的问题。台风、雾霾或飞机故障等众多因素都有可能导致大面积航班延误的情况，大面积延误给旅客出行带来很多不便。目前市场上关于航班延误预测产品大多输入因素较少且预测提前期短，很难为航司、机场以及旅客提供准确的预测结果。因此如何在计划起飞前预测航班延误情况，让出行旅客更好的规划出行方式，成为一个重大课题。

## 2. 数据获取及预处理 
### 2.1 数据来源
>&emsp;&emsp;此次作业使用的数据集包括历史航班动态起降数据、历史城市天气表、机场城市对应表以及历史机场特情表等，全部数据集从携程官网获得。数据下载地址：https://pan.baidu.com/s/1-DjCdGbwkP7UtOtJaqwHdg, 提取码: zmss 
***  
### 2.2 数据说明  
* 航班具体数据预览如下：     

| 编号 | 出发机场 | 到达机场 | 航班编号 | 飞机编号 | 计划飞行时间 | 计划起飞时刻 | 航班月份 | 计划到达时刻 | 起飞延误时间 | 前序延误 | 起飞间隔 | 到达特情 | 出发特情 | 出发天气 | 出发气温 | 到达天气   | 到达气温 | 航空公司 | 航班性质 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 0    | JHG      | KMG      | 8L9903A  | 0        | 1.083333     | 16           | 4        | 17           | 0.966667     |          |          | 0        | 0        |          |          |            |          | 8L       | 0        |
| 1    | JHG      | KMG      | 8L9905A  | 0        | 0.833333     | 17           | 4        | 18           | 0.116667     |          |          | 0        | 0        |          |          |            |          | 8L       | 0        |
| 2    | PEK      | HGH      | GJ8888   | 0        | 2.25         | 21           | 4        | 0            | 0.333333     |          |          | 0        | 0        |          |          | 多云转中雨 | 一般     | GJ       | 1        |
| 3    | PEK      | DQA      | CA1683   | 0        | 2.166667     | 22           | 4        | 0            | 10           |          |          | 0        | 0        |          |          | 阵雨转多云 | 一般     | CA       | 1        |
| 4    | HAK      | SZX      | DZ6262   | 0        | 1.166667     | 22           | 4        | 23           | 0.15         |          |          | 0        | 0        |          |          |            |          | DZ       | 1        |
| 5    | PEK      | XNN      | CZ6994   | 0        | 2.666667     | 22           | 4        | 1            | 10           |          |          | 0        | 0        |          |          | 多云       | 一般     | CZ       | 1        |
| 6    | CKG      | URC      | 3U8871   | 0        | 4.083334     | 23           | 4        | 3            | 10           |          |          | 0        | 0        |          |          | 晴         | 一般     | 3U       | 1        |
| 7    | PEK      | CTU      | CA4194   | 0        | 2.916667     | 23           | 4        | 1            | 10           |          |          | 0        | 0        |          |          | 多云       | 一般     | CA       | 1        |
| 8    | CAN      | XMN      | CZ3723   | 0        | 1.166667     | 23           | 4        | 0            | 10           |          |          | 0        | 0        |          |          | 阴         | 一般     | CZ       | 1        |
只展示了前五行数据。航班具体数据有出发机场、到达机场、航班编号、飞机编号、计划飞行时间、计划起飞时刻、航班月份、计划到达时刻、起飞延误时间、前序延误、起飞间隔、到达特情、出发特情、出发天气、出发气温、到达天气、到达气温、航空公司、航班性质。
***  
### 2.3 数据预处理
* 历史航班动态数据预处理：  
    ① utc 时间转换为标准时间格式  
    ② 计算起飞延误时间和到达延误时间  
    ③ 取消航班全部设置为延误 10 小时  
    ④ 计算计划飞行时间  
    ⑤ 前序航班到达延误时间  
    ⑥ 起飞间隔定义为当前航班的计划起飞时间与前序航班的时间到达时间差值  
    ⑦ 根据航班号提取出航空公司的代号,根据航班号的特征，把航班分为 3 种：尾号为字母的是补飞的，3 位数字国外航班，4 位数字国内航班
***
* 城市天气表数据预处理：  
    ① 气温  
气温划分为 3 个取值，大于 40 度为高温，小于 -10 度为低温，其他为一般。  
    ② 天气情况    
天气情况（小雨、阴天等）根据城市天气表，首先统计两年时间内所有天气
情况在各地区总共出现的频率，出现频率小于 50 的天气情况统一划归为
‘other’。
***

* 机场特情表预处理：  
    ① 根据开始时间提取出特情开始日期、开始时刻  
    ② 根据结束时间提取出特情结束日期、结束时刻
***

* 时间信息处理

```python
# 转化成日期格式
flight_data['计划起飞时间1'] = pd.to_datetime(flight_data['计划出发时间'],unit='s',utc=True)
flight_data['计划到达时间1'] = pd.to_datetime(flight_data['计划到达时间'],unit='s',utc=True)
# 计划飞行时间
flight_data['计划飞行时间'] = flight_data['计划到达时间1'] - flight_data['计划起飞时间1']
flight_data['计划飞行时间'] = flight_data['计划飞行时间'].apply(lambda x: x.days * 86400 + x.seconds if not(pd.isnull(x)) else None)

flight_data['计划飞行时间'] = flight_data['计划飞行时间']/3600  # 转换为小时
# 细分时间段
flight_data['计划起飞日期'] = flight_data['计划起飞时间1'].apply(lambda x:x.strftime('%Y-%m-%d') if not(pd.isnull(x)) else None)
flight_data['计划起飞时刻'] = flight_data['计划起飞时间1'].apply(lambda x:x.strftime('%H') if not(pd.isnull(x)) else None)
flight_data['航班月份'] = flight_data['计划起飞时间1'].apply(lambda x:int(x.strftime('%m')) if not(pd.isnull(x)) else None)

flight_data['计划到达日期'] = flight_data['计划到达时间1'].apply(lambda x:x.strftime('%Y-%m-%d') if not(pd.isnull(x)) else None)
flight_data['计划到达时刻'] = flight_data['计划到达时间1'].apply(lambda x:x.strftime('%H') if not(pd.isnull(x)) else None)
#延误
flight_data['起飞延误时间'] = pd.to_datetime(flight_data['实际出发时间'],unit='s',utc=True) - pd.to_datetime(flight_data['计划出发时间'],unit='s',utc=True)
flight_data['起飞延误时间'] = flight_data['起飞延误时间'].apply(lambda x: x.days * 86400 + x.seconds if not(pd.isnull(x)) else None)
flight_data['起飞延误时间'] = flight_data['起飞延误时间']/3600  # 转换为分钟
flight_data['起飞延误时间'] = np.where(flight_data['取消标识'] == '取消',10,flight_data['起飞延误时间'])

flight_data['到达延误时间'] = pd.to_datetime(flight_data['实际到达时间'],unit='s',utc=True) - pd.to_datetime(flight_data['计划到达时间'],unit='s',utc=True)
flight_data['到达延误时间'] = flight_data['到达延误时间'].apply(lambda x: x.days * 86400 + x.seconds if not(pd.isnull(x)) else None)
flight_data['到达延误时间'] = flight_data['到达延误时间']/3600  # 转换为分钟
flight_data['到达延误时间'] = np.where(flight_data['取消标识'] == '取消',10,flight_data['到达延误时间'])

del flight_data['计划起飞时间1']
del flight_data['计划到达时间1']
del(flight_data['实际出发时间'])
del(flight_data['取消标识'])
```

***
* 纠正部分错误
```python
flight_data['航班编号1'] = flight_data['飞机编号']
flight_data['飞机编号'] = flight_data['航班编号']
flight_data['航班编号'] = flight_data['航班编号1']
del(flight_data['航班编号1'])
```
***
* 均值填充缺失值    
```python
train_data['到达天气'] = train_data['到达天气'].astype('object')
train_data['到达天气']=train_data['到达天气'].fillna('0')
train_data['出发天气'] = train_data['出发天气'].astype('object')
train_data['出发天气']=train_data['出发天气'].fillna('0')
train_data['前序延误']=train_data['前序延误'].fillna(train_data['前序延误'].mean()) #均值填充
train_data['出发气温'] = train_data['出发气温'].astype('object')
train_data['出发气温']=train_data['出发气温'].fillna('一般')
train_data['到达气温'] = train_data['到达气温'].astype('object')
train_data['到达气温']=train_data['到达气温'].fillna('一般')
train_data['起飞间隔'] = train_data['起飞间隔'].fillna(train_data['起飞间隔'].mean())#均值填充
```
***  
## 3. 数据分析与可视化
### 3.1 航班动态 （部分）
编号  |出发机场 | 到达机场 | 航班编号 | 气计划起飞时间 | 计划到达时间| 实际起飞时间| 实际到达时间| 飞机编号| 航班是否取消      
  :-: |:-:| :-:| :-: | :-: | :-:   | :-:   | :-:   | :-:   | :-:  
 0|HGH  |DLC|CZ6328|1453809600|	1453817100|	1453813080|	1453819380	|1.0|	正常  
 1|SHA	|XMN|FM9261|1452760800|	1452767100|	1452762600|	1452767940	|2.0|	正常 
 2|CAN  |WNZ|ZH9597|1453800900|	1453807500|	1453802340|	1453806840	|3.0|	正常 
 3|SHA	|ZUH|9C8819|1452120600| 1452131100| 1452121440|	1452129840  |4.0|   正常
 4|SHE	|TAO|TZ185 |1452399000|	1452406800| 1452399900| 1452404340	|5.0|   正常
***  
### 3.2 城市天气对应图（部分）   

  编号  |城市 | 天气 | 日期 | 气温 | 机场编码      
:-: |:-:| :-:| :-: | :-: | :-:  
2 | 石河子| 多云  | 2017-07-11   | 一般 | SHF
106 | 喀什| 晴转多云  | 2017-07-01   | 一般 | KHG
158 | 库车| 晴  | 2017-07-11   | 一般 | KCA
179 | 腾冲| 大雨| 2017-07-11   | 一般 | TCZ
199   | 井冈山| 雷阵雨转阵雨  | 2017-07-11   | 一般 | JGS

***  
### 3.3 特殊情况 
| 特情机场 | 收集时间             | 开始时间             | 结束时间             | 特情内容            |
|----------|----------------------|----------------------|----------------------|------------------------------------------------------------------------------------------------------------|
| csx      | 2015-04-30 19:52:45Z | 2015-05-01 12:00:00Z | 2015-05-01 16:00:00Z | 长沙机场航班延误黄色预警提示：预计明日（5月1日）12:00-16:00长沙黄花机场受雷雨天气影响，通行能力下降20%左右 |
| wuh      | 2015-05-01 08:13:39Z | 2015-05-01 08:00:00Z | 2015-05-01 12:00:00Z | 目前，8时-12时雷雨，期间进出港航班可能受到影响。                                                           |
| khn      | 2015-05-01 08:14:18Z | 2015-05-01 14:00:00Z | 2015-05-01 17:00:00Z | 预计，14时-17时小雷雨，期间进出港航班可能受到影响。                                                        |
| swa      | 2015-05-01 08:24:28Z | 2015-05-01 13:00:00Z | 2015-05-01 17:00:00Z | 预计，13时-17时雷雨，期间进出港航班可能受到影响。                                                          |
| zha      | 2015-05-01 08:24:56Z | 2015-05-01 13:00:00Z | 2015-05-01 17:00:00Z | 预计，13时-17时雷雨，期间进出港航班可能受到影响。                                                          |
| cih      | 2015-05-01 08:25:22Z | 2015-05-01 13:00:00Z | 2015-05-01 17:00:00Z | 预计，13时-17时小雷雨，期间进出港航班可能受到影响。                                                        |
| xuz      | 2015-05-01 08:26:01Z | 2015-05-01 23:00:00Z | 2015-05-01 23:59:00Z | 预计，23时-00时小雷雨，期间进出港航班可能受到影响。                                                        |
| nny      | 2015-05-01 08:26:31Z | 2015-05-01 08:00:00Z | 2015-05-01 12:00:00Z | 预计，08时-12时小雷雨，期间进出港航班可能受到影响。                                                        |
| xil      | 2015-05-01 08:27:04Z | 2015-05-01 08:00:00Z | 2015-05-01 12:00:00Z | 目前，08时-17时低能见度102米，期间进出港航班可能受到影响。                                                 |
| wus      | 2015-05-01 08:27:37Z | 2015-05-01 14:00:00Z | 2015-05-01 17:00:00Z | 预计，14时-17时雷雨，期间进出港航班可能受到影响。                                                          |
| ybp      | 2015-05-01 08:28:06Z | 2015-05-01 09:00:00Z | 2015-05-01 11:00:00Z | 预计，09时-11时小雷雨，期间进出港航班可能受到影响。                                                        |
| dyg      | 2015-05-01 08:28:45Z | 2015-05-01 08:00:00Z | 2015-05-01 12:00:00Z | 目前，08时-12时雷雨，期间进出港航班可能受到影响。                                                          |
| ten      | 2015-05-01 08:29:20Z | 2015-05-01 08:00:00Z | 2015-05-01 17:00:00Z | 目前，08时-17时低能见度800米，10时-11时低云约60米，期间进出港航班可能受到影响。                            |
| foc      | 2015-05-01 08:30:40Z | 2015-05-01 08:00:00Z | 2015-05-01 09:30:00Z | 目前，机场受轻雾天气影响，较大面积延误，期间进出港航班可能受到影响。                                       |
***  
## 4. 模型选取   

### 4.1 算法流程
![图片](./pictures/1.png)   

***
### 4.2 模型选取
>&emsp;&emsp;本次作业所选模型为 GBDT (Gradient Boosting Decision Tree)模型，梯度提升决策树（Gradient Boosting Decision Tree）是一种基于决策树的算法。该算法由多棵决策树组成，对所有树的结论进行累加得到最终答案。它和SVM都被认为是泛化能力较强的算法。GDBT中使用到的树是回归树。它可以用来进行回归预测，经过调整后也可以用于分类任务。本次作业直接调用了sklearn.sklearn.ensemble, GradientBoostingClassifier()方法，并进行相关的参数调整。为了选取较优的参数，首先将编码后的数据集按照 3:1 的比例随机划分为训练集和验证集,以调整参数。

* 4.2.1 回归树  
&emsp;&emsp;回归树总体流程类似于分类树，区别在于，回归树的每一个节点都会得一个预测值，以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个feature的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化平方误差。也就是被预测出错的人数越多，错的越离谱，平方误差就越大，通过最小化平方误差能够找到最可靠的分枝依据。分枝直到每个叶子节点上人的年龄都唯一或者达到预设的终止条件(如叶子个数上限)，若最终叶子节点上人的年龄不唯一，则以该节点上所有人的平均年龄做为该叶子节点的预测年龄。
    
    >算法：最小二乘回归树生成算法
    输入：训练数据$D$
    输出：回归树$f(x)$
    在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树：
    (1) 选择最优且分变量$j$和切分点$s$，构建二叉决策树：
    $$\min_{j,s}\Big[\min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\min_{c_2} \sum_{x_i \in R_2(j,s)}(y_i-c_2)^2\Big]$$
    遍历变量$j$，对固定的切分变量$j$扫描切分点$s$，选择使上式达到最小值的$(j,s)$。
    (2) 用选定的$(j,s)$划分区域并决定相应的输出值：
    $$R_1(j,s)=\{x|x^{(j)} \leq s\},\ R_2(j,s)=\{x|x^{(j)} \geq s\}$$
    $$\hat{c}_m=\frac{1}{N_m}\sum_{x_i \in R_m(j,s)}y_I,\ x\in R_m,\ m=1,2$$
    (3) 继续对两个子区域调用步骤(1)、(2)，知道满足停止条件。
    (4) 将输入控件划分为$M$个区域：$R_1,R_2,...,R_M$，生成决策树：
    $$f(x)=\sum_{m=1}^{M}\hat{c}_mI,\ x \in R_m$$

***
* 4.2.2 提升树 
&emsp;&emsp;提升树是迭代多棵回归树来共同决策。当采用平方误差损失函数时，每一棵回归树学习的是之前所有树的结论和残差，拟合得到一个当前的残差回归树，残差的意义如公式：残差 = 真实值 - 预测值 。提升树即是整个迭代过程生成的回归树的累加。提升树模型可以表示为决策树的夹发模型：  
$$f_M(x)=\sum_{m=1}^MT(x;\theta_m)$$
其中$T\left(x;\theta_m\right)$表示一颗决策树，$\theta_m$是决策树的参数，$M$是决策树的个数。
***
* 4.2.3 梯度提升决策树  
&emsp;&emsp;GBDT（Gradient Boosting Decision Tree）是一种迭代的决策树算法，又叫 MART（Multiple Additive Regression Tree)，它通过构造一组弱的学习器（树），并把多颗决策树的结果累加起来作为最终的预测输出。该算法将决策树与集成思想进行了有效的结合。  
&emsp;&emsp;我们需要知道的是，度量任何一个模型最重要的就是这个模型的损失函数。我们训练的目标就是使得损失函数L最小化。
$$\theta^*=arg \min_\theta\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i;\theta))+\lambda \Phi(\theta)$$
&emsp;&emsp;当损失函数是平方损失和指数损失时，每一步优化是很简单的。但对一般损失函数而言，往往每一步优化没那么容易，如绝对值损失函数和Huber损失函数。对于损失函数为平方损失函数的情况，我们可以使用的是y_j-T_i对x_i的预测结果作为残差。对于其它类型的损失函数，Freidman提出了梯度提升算法：利用最速下降的近似方法，即利用损失函数的负梯度在当前模型的值。
    $$-\Big[\frac{\partial L(y,f(x_i))}{\partial f(x_i)}\Big]_{f(x)=f_{m-1}(x)}$$
&emsp;&emsp;对提升树的损失函数求偏导可以发现偏导和残差相等，上式展示了这一过程。因此对于不同的损失函数，可以使用损失函数的偏导数作为残差。
*** 

### 4.3 模型训练

```python
from sklearn.ensemble import GradientBoostingClassifier
test = test_data.copy()
# 设置参数
gbdt = GradientBoostingClassifier(loss='exponential',n_estimators=300,max_depth=5,learning_rate=0.08,min_samples_leaf=500,subsample=0.8)
# 训练
gbdt.fit(train_data,targets)
# 预测结果
pre_y = gbdt.predict_proba(test)[:,1]

```
## 5. 挖掘实验的结果

### 5.1 基于GBDT方法的调参步骤
* 学习器个数（$n\_estimators$）   
保持其它默认参数不变， 考虑到样本量较大，故将学习器的个数设置大一些，分别将 $n\_estimators$ 设置为 100、200、300、400，发现$AUC$的得分是随着$n\_estimators$的增多而变大，但学习器个数 300 和 400 之间$AUC$得分增加的已不明显，并且要兼顾到模型训练时间开销，所以设置$n\_estimators$ = 300。
*** 
* $loss function(loss)$  
保持学习器个数不变 ，改变$loss$ ，观察结果，选一个较优的，本算法择了 $loss = 'exponential'$。
*** 
* 树的最大深度（$max\_depth$），叶子的最小样本个数（ $min\_samples\_leaf$ ）  
保持学习器个数和 $loss\ function$ 不变，调整 $max\_depth$ 和 $min\_samples\_leaf$。 $max\_depth$ 越大，树的结构复杂，组合特征能力强拟越强，拟合能力越强，但同时更容易过拟合，分别设置 $max\_depth$ 为4,6,8,10， $min\_samples\_leaf$ 的个数逐渐调大，范围在 $50-500$ 之间。
*** 
* 下采样率（$subsample$）  
$subsample$ = 0.8,一般情况下都比较好。
*** 
* 学习率  
学习率默认设置为 0.1 ，学习率过大容易错过最优解，所以后适当缩小率的值。但减小学习率，收敛速度变慢，这时候适当增加器个数，最终学习率设置为 0.08 。

*** 
### 5.2 实验结果
* 5.2.1 中间结果：特征重要性图  
![图片](./pictures/2.png)   
提取出各个属性值的特征
*** 
* 5.2.2 中间结果：天气预测结果  

编号|天气预测结果| 
:-:|:-:|
0|晴转多云|
 1|中雨转多云|
2|晴转小雪|
3|阳光明媚|
4|雨夹雪转中雪|

此天气预测结果为中间数据，进行航班预测会需要天气预测结果，下一步的航班预测结果会根据天气预测结果进行航班的延误预测。
*** 
* 5.2.3 航班预测结果  

||Flightno| FlightDepcode|FlightArrcode|PlannedDeptime|PlannedArrtime|prob
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
0|G5281X|DOY|DLC|1498863600|1498866000|0.056657
1|GY7113|KWE|KHN|1498863600|1498869900|0.779410
2|JR1549|TXN|CGO|1498863600|1498874100|0.950355
3|SC4959|TNA|SYX|1498863600|1498883100|0.985184
4|SC4959|TNA|XMN|1498863600|1498871700|0.959803

进行模型训练之后，预测出航班的计划起飞时间和计划到达时间，以及AUC评分结果。
*** 
* 5.2.4 GBDT模型的AUC评分
```python
--> start
==> get positive samples: 14296
==> get negative samples: 7148
---------  Modeling ------------
--------------------------------
Fold: 0
==> GBDT.model had been trained.
| AUC (Train):	0.538348996478
| AUC Score (test):	0.53617048386

--------------------------------
```
* 5.2.5 GBDT_LR模型的AUC评分
```python
--> start
==> get positive samples: 14296
==> get negative samples: 7148
---------  Modeling ------------
--------------------------------
Fold: 0
==> GBDT_LR.model had been trained.
| AUC (Train):	0.551328874681
| AUC Score (test):	0.541967110455

--------------------------------
```

|Dataset|GBDT|GBDT+LR|
|:-:|:-:|:-:|
|AUC(Train)|0.538348996478|0.551328874681|
|AUC(TEST)|0.53617048386|0.541967110455|

*** 
## 6. 结果分析

>&emsp;&emsp;为了做对比实验以及筛选得到更好的训练效果，我们选择了两种模型：GBDT和GBDT+LR混合模型。在单独GBDT模型下，训练集AUC为：0.538348996478，测试集AUC为：0.53617048386；在GBDT+LR混合模型下，训练集AUC为：0.551328874681，测试集AUC为：0.551328874681。
&emsp;&emsp;从以上结果可以看出在训练了两个模型并通过5折交叉验证后，计算出了最终的AUC评分，结果显示单独使用GBDT模型的AUC得分略低于GBDT+LR混合模型的得分，最终决定选择GBDT+LR的混合模型。
&emsp;&emsp;对于上述两种结果，其AUC评分均较低，都没有出现很好的预测结果，我们分析后认为存在模型选取、数据量不足以及存在过拟合现象等原因。由于是在笔记本上跑数据模型，训练一次数据会消耗两天时间，硬件原因不支持我们选取更大的数据集进行模型训练，在以后算力充足的条件下，可以尝试着对数据进行数据增强的操作，将数据扩增到百万甚至千万级别，并且在训练过程中使用正则化条件来防止过拟合现象，相信会得到一个效果更佳的预测结果。

*** 
</font> 